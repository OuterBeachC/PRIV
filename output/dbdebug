import pandas as pd
import sqlite3

# Debug script to check date formats in your database
def debug_date_formats(db_file="priv_data.db"):
    """
    Debug function to examine date formats in the database
    """
    try:
        # Connect to database
        conn = sqlite3.connect(db_file)
        
        # Read all dates from the database
        query = "SELECT DISTINCT date FROM financial_data ORDER BY date"
        dates_df = pd.read_sql_query(query, conn)
        
        print("=== DATABASE DATE ANALYSIS ===")
        print(f"Total unique dates found: {len(dates_df)}")
        print("\nFirst 10 date values:")
        for i, date_val in enumerate(dates_df['date'].head(10)):
            print(f"  [{i+1}]: '{date_val}' (type: {type(date_val)})")
        
        print("\nLast 10 date values:")
        for i, date_val in enumerate(dates_df['date'].tail(10)):
            print(f"  [{i+1}]: '{date_val}' (type: {type(date_val)})")
        
        # Check for null/empty dates
        null_dates = dates_df['date'].isnull().sum()
        empty_dates = (dates_df['date'] == '').sum()
        print(f"\nNull dates: {null_dates}")
        print(f"Empty string dates: {empty_dates}")
        
        # Try to identify problematic dates
        print("\n=== TESTING DATE PARSING ===")
        problematic_dates = []
        
        for date_val in dates_df['date']:
            try:
                pd.to_datetime(date_val)
            except:
                problematic_dates.append(date_val)
        
        if problematic_dates:
            print(f"Found {len(problematic_dates)} problematic dates:")
            for date_val in problematic_dates[:10]:  # Show first 10
                print(f"  PROBLEM: '{date_val}' (type: {type(date_val)})")
        else:
            print("✅ All dates can be parsed successfully!")
        
        conn.close()
        return problematic_dates
        
    except Exception as e:
        print(f"Error analyzing database: {str(e)}")
        return None

# Fixed load_data function for Streamlit
def fixed_load_data(db_file="priv_data.db"):
    """
    Fixed version of load_data function with better date handling
    """
    try:
        conn = sqlite3.connect(db_file)
        df = pd.read_sql_query("SELECT * FROM financial_data", conn)
        conn.close()
        
        print(f"Loaded {len(df)} rows from database")
        
        # Debug: Check date column before conversion
        print("Date column info before conversion:")
        print(f"  Unique values: {df['date'].nunique()}")
        print(f"  Null values: {df['date'].isnull().sum()}")
        print(f"  Data types: {df['date'].dtype}")
        
        # Clean and convert dates with error handling
        print("Converting dates...")
        
        # Method 1: Try direct conversion with error handling
        try:
            df["date"] = pd.to_datetime(df["date"], errors='coerce')
            invalid_dates = df["date"].isnull().sum()
            if invalid_dates > 0:
                print(f"Warning: {invalid_dates} dates could not be parsed and were set to NaT")
        except Exception as e:
            print(f"Direct conversion failed: {e}")
            
            # Method 2: Manual cleaning approach
            print("Trying manual date cleaning...")
            
            def clean_date(date_val):
                if pd.isnull(date_val) or date_val == '':
                    return None
                try:
                    return pd.to_datetime(str(date_val).strip())
                except:
                    print(f"Could not parse date: '{date_val}'")
                    return None
            
            df["date"] = df["date"].apply(clean_date)
        
        # Remove rows with invalid dates
        initial_rows = len(df)
        df = df.dropna(subset=['date'])
        final_rows = len(df)
        
        if initial_rows != final_rows:
            print(f"Removed {initial_rows - final_rows} rows with invalid dates")
        
        print(f"Final dataset: {len(df)} rows with valid dates")
        return df
        
    except Exception as e:
        print(f"Error loading data: {str(e)}")
        return None

if __name__ == "__main__":
    # Run the debugging
    print("Running database date analysis...")
    problematic_dates = debug_date_formats()
    
    print("\n" + "="*50)
    print("Testing fixed load_data function...")
    df = fixed_load_data()
    
    if df is not None:
        print(f"\n✅ Successfully loaded {len(df)} rows")
        print(f"Date range: {df['date'].min()} to {df['date'].max()}")
    else:
        print("\n❌ Failed to load data")